#' Predictive Uncertainty functions
#'
#' @describeIn predict_uncertainty_calibration Predictive Uncertainty Calibration
#'
#' Model of predictive uncertainty based on quantiles of the empirical
#' distribution of relative errors for different bins of simulated discharge
#' values using a moving bin approach.
#'
#' @details
#' This method is based on the approach described in Bourgin (2014) pages 201-203
#' with a variant consisting in moving a bin along the distribution of
#' simulated discharge instead of fixed bins.
#'
#' References:
#'
#' Bourgin, François. 2014. « Comment quantifier l’incertitude prédictive en
#' modélisation hydrologique ? : Travail exploratoire sur un grand échantillon
#' de bassins versants ». Phdthesis, AgroParisTech.
#' https://pastel.archives-ouvertes.fr/tel-01130084.
#'
#' @param Qobs Observed discharge values (numeric vector).
#' @param Qsim Simulated discharge values (numeric vector).
#' @param bind_size Size of the moving bin as a fraction of the data range (default is 0.1).
#' @param bind_step Step size for moving the bin as a fraction of the data range (default is 0.01).
#' @param FUN_TRANS Transformation function to apply to discharge values (default is log10).
#' @param probs Probabilities for quantile calculation (default is c(0.05, 0.5, 0.95))
#' for a 90% prediction interval.
#'
#' @return A data frame with columns:
#' - `Qmin`: Minimum discharge value of the bin.
#' - `Qmax`: Maximum discharge value of the bin.
#' - Quantiles of the relative error (Qsim / Qobs) for the specified probabilities.
#'
#' Each row corresponds to a bin defined by `bind_size` and `bind_step`.
#'
#' @example man-example/predict_uncertainty.R
#' @export
#'
predict_uncertainty_calibration <- function(
  Qobs,
  Qsim,
  bind_size = 0.1,
  bind_step = 0.01,
  FUN_TRANS = log10,
  confidence_interval = 0.90,
  probs = c(
    (1 - confidence_interval) / 2,
    1 - (1 - confidence_interval) / 2
  )
) {
  stopifnot(length(Qobs) == length(Qsim))
  Qsim[is.na(Qobs)] <- NA_real_
  Qobs <- Qobs[!is.na(Qobs)]
  Qsim <- Qsim[!is.na(Qsim)]
  QsimT <- FUN_TRANS(Qsim)
  qQsimT <- quantile(QsimT, probs = seq(0, 1, bind_step), type = 7)
  l <- lapply(seq(bind_step, 1 - bind_step, bind_step), function(p) {
    lower <- max(0, min(1 - bind_size, p - bind_size / 2)) * 100 + 1
    upper <- min(1, max(bind_size, p + bind_size / 2)) * 100 + 1
    indices <- QsimT >= qQsimT[lower] & QsimT <= qQsimT[upper]
    e_r_i <- Qobs[indices] / Qsim[indices]
    q_e_r_i <- quantile(e_r_i, probs = probs, na.rm = TRUE, type = 7)
    ind_p <- p * 100 + 1
    Qmin <- 10^((qQsimT[ind_p - 1] + qQsimT[ind_p]) / 2)
    Qmax <- 10^((qQsimT[ind_p] + qQsimT[ind_p + 1]) / 2)
    if (p == bind_step) {
      Qmin <- 0
    } else if (p == 1 - bind_step) {
      Qmax <- Inf
    }
    return(c(Qmin = unname(Qmin), Qmax = unname(Qmax), q_e_r_i))
  }) %>%
    dplyr::bind_rows()
}

#' @describeIn predict_uncertainty_calibration Predictive Uncertainty Prediction
#' Using the uncertainty table generated by `predict_uncertainty_calibration`,
#' this function predicts the relative uncertainty for new simulated discharge values.
#' @export
predict_uncertainty <- function(Qsim, uncertainty_table) {
  Q_classes <- c(0, uncertainty_table$Qmax)
  Qsim_classes <- cut(
    Qsim,
    breaks = Q_classes,
    include.lowest = TRUE,
    labels = FALSE
  )
  e_rel_pred <- lapply(seq_along(Qsim), function(i) {
    cls <- Qsim_classes[i]
    if (is.na(cls)) {
      return(NA_real_)
    } else {
      return(Qsim[i] * uncertainty_table[cls, -c(1, 2)])
    }
  }) %>%
    dplyr::bind_rows()
  return(cbind(Qsim = Qsim, e_rel_pred))
}

#' @describeIn predict_uncertainty_calibration Plot Predicted Uncertainty Time Series.
#' This function visualizes the predicted discharge values along with their uncertainty intervals.
#' @param QSim_uncertain Data frame returned by `predict_uncertainty`, containing simulated discharge and uncertainty quantiles.
#' @param DatesR Dates corresponding to the discharge values.
#' @param bounds Names of the columns in `QSim_uncertain` representing the uncertainty bounds (default is the first and last error quantile).
#' @export
plot_uncertainty_time_series <- function(
  Qsim_uncertain,
  DatesR,
  Qobs = NULL,
  bounds = names(Qsim_uncertain)[c(2, ncol(Qsim_uncertain))],
  rubbon_fill = "darkblue",
  rubbon_alpha = 0.2,
  line_colors = c("Simulated" = "orangered", "Observed" = "black"),
  labels = list(
    title = "Predicted Discharge with Uncertainty Intervals",
    x = "Date",
    y = "Discharge (mm)",
    color = "Flow type"
  )
) {
  # Checks
  for (bound in bounds) {
    if (!(bound %in% names(Qsim_uncertain))) {
      stop(paste("Bound", bound, "not found in Qsim_uncertain"))
    }
  }
  stopifnot(names(line_colors) == c("Simulated", "Observed"))

  Qsim_uncertain <- Qsim_uncertain %>%
    select(Qsim, all_of(bounds)) %>%
    rename(
      `upper_bound` = !!bounds[1],
      `lower_bound` = !!bounds[2]
    ) %>%
    mutate(DatesR = DatesR, Qobs = Qobs)

  # build long data for plotting; if Qobs is NULL or all NA, only include Simulated
  if ("Qobs" %in% names(Qsim_uncertain) && any(!is.na(Qsim_uncertain$Qobs))) {
    Qsim_Qobs_long <-
      Qsim_uncertain %>%
      select(DatesR, Qsim, Qobs) %>%
      rename(Simulated = Qsim, Observed = Qobs) %>%
      pivot_longer(
        cols = -DatesR,
        names_to = "Flow type",
        values_to = "QsimQobs"
      )
  } else {
    Qsim_Qobs_long <-
      Qsim_uncertain %>%
      select(DatesR, Qsim) %>%
      rename(Simulated = Qsim) %>%
      pivot_longer(
        cols = -DatesR,
        names_to = "Flow type",
        values_to = "QsimQobs"
      )
  }

  # Create the plot directly from the wide format
  ggplot(data = Qsim_uncertain, aes(x = DatesR)) +
    geom_ribbon(
      aes(ymin = `upper_bound`, ymax = `lower_bound`),
      fill = rubbon_fill,
      alpha = rubbon_alpha
    ) +
    geom_line(
      data = Qsim_Qobs_long,
      aes(x = DatesR, y = QsimQobs, color = `Flow type`),
      linewidth = 1
    ) +
    scale_color_manual(
      values = line_colors
    ) +
    do.call(labs, labels) +
    theme_minimal()
}

#' @describeIn predict_uncertainty_calibration Plot Predicted Uncertainty Calibration.
#' This function visualizes the relative error between observed and simulated
#' discharge values,
#' along with the predicted uncertainty intervals.
#' @param outliers_quantile Quantile threshold to filter out extreme relative
#' errors (default is 0.999).
#' @param labels List of labels for the plot (title, x, y, ...) used in
#' [ggplot2::labs()].
#' @export
plot_uncertainty_calibration <- function(
  Qsim_uncertain,
  Qobs,
  bounds = names(Qsim_uncertain)[c(2, ncol(Qsim_uncertain))],
  rubbon_fill = "darkblue",
  rubbon_alpha = 0.2,
  outliers_quantile = 0.999,
  labels = list(
    title = "Relative Error vs. Simulated Discharge with Uncertainty Intervals",
    x = "Simulated Discharge (mm)",
    y = "Relative Error Qobs/Qsim (-)"
  )
) {
  valid_rows <- !is.na(Qobs)
  Qobs_valid <- Qobs[valid_rows]
  df_errors <- Qsim_uncertain[valid_rows, ] %>%
    select(Qsim, all_of(bounds)) %>%
    mutate(obs = Qobs_valid) %>%
    arrange(Qsim) %>%
    rename(
      `upper_bound` = !!bounds[1],
      `lower_bound` = !!bounds[2]
    ) %>%
    mutate(
      err_obs = obs / Qsim,
      err_upper = upper_bound / Qsim,
      err_lower = lower_bound / Qsim
    )
  # Remove outliers
  err_threshold <- quantile(
    df_errors$err_obs,
    probs = c(1 - outliers_quantile, outliers_quantile),
    na.rm = TRUE
  )
  df_errors <- df_errors %>%
    filter(err_obs >= err_threshold[1] & err_obs <= err_threshold[2])

  ggplot(data = df_errors, aes(x = Qsim, y = err_obs)) +
    geom_point(color = "orangered", size = 0.5) +
    geom_ribbon(
      aes(ymin = err_lower, ymax = err_upper),
      fill = rubbon_fill,
      alpha = rubbon_alpha
    ) +
    scale_x_log10(
      labels = scales::scientific_format(digits = 1, scale = 1)
    ) +
    scale_y_log10(
      labels = scales::scientific_format(digits = 1, scale = 1)
    ) +
    do.call(labs, labels) +
    theme_minimal()
}
